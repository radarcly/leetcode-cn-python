# 300. 最长递增子序列
难度 中等 

完成日期 2021.3.4


## 1.题干
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

## 2.示例
### 示例1
输入：nums = [10,9,2,5,3,7,101,18]

输出：4

解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

### 示例2
输入：nums = [0,1,0,3,2,3]

输出：4

### 示例3
输入：nums = [7,7,7,7,7,7,7]

输出：1

## 3.提示
1 <= nums.length <= 2500

-104 <= nums[i] <= 104

## 4.进阶
你可以设计时间复杂度为 O(n2) 的解决方案吗？

你能将算法的时间复杂度降低到 O(n log(n)) 吗?

## 5.解题思路

### 方法一 ：动态规划
定义dp[i] 为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，注意nums[i]必须被选取。

我们从小到大计算dp数组的值，在计算dp[i]之前，我们已经计算出dp[0…i−1] 的值，则状态转移方程为：

dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]

即考虑往dp[0…i−1]中最长的上升子序列后面再加一个nums[i]。由于dp[j]代表nums[0…j]中以nums[j]结尾的最长上升子序列，
所以如果能从dp[j]这个状态转移过来，那么nums[i]必然要大于nums[j]，才能将nums[i]放在nums[j]后面以形成更长的上升子序列。

最后，整个数组的最长上升子序列即所有dp[i]中的最大值。

LISlength=max(dp[i]),其中0≤i<n

#### 算法复杂度
时间复杂度：O(n^2)，其中n为数组nums的长度。动态规划的状态数为n，计算状态dp[i]时，需要O(n)的时间遍历dp[0…i−1] 的所有状态，所以总时间复杂度为O(n^2)

空间复杂度：O(n)，需要额外使用长度为n的dp数组。

### 方法二：贪心 + 二分查找
注意:解法二和1438解法二里的单调队列维护方法类似。本质关键是具体序列不重要，重要的是长度，所以贪心法维护序列最后只看长度就行。

思路与算法

考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。

基于上面的贪心思路，我们维护一个数组d[i]，表示长度为i的最长上升子序列的末尾元素的最小值，用len记录目前最长上升子序列的长度，起始时len为1，d[1]=nums[0]。

我们依次遍历数组nums中的每个元素，并更新数组d和len的值。如果nums[i]>d[len]则更新len=len+1，否则在d[1…len]中找满足d[i−1]<nums[j]<d[i] 的下标i，并更新d[i]=nums[j]。

根据d数组的单调性，我们可以使用二分查找寻找下标i，优化时间复杂度。

#### 算法复杂度
时间复杂度：O(nlogn)。数组nums的长度为n，我们依次用数组中的元素去更新d数组，而更新d数组时需要进行O(logn) 的二分搜索，所以总时间复杂度为O(nlogn)。

空间复杂度：O(n)，需要额外使用长度为n的d数组。

### 其他
有时候贪心才是最难想的

贪心算法听起来比动态规划简单，实际上，使用贪心算法找到全局最优解需要额外考虑很多东西来避免陷入局部最优。
如何保证贪心算法能够找到全局最优，是一个难点。