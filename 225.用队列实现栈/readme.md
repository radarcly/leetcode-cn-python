# 225.用队列实现栈
难度 简单 

完成日期 2021.3.5


## 1.题干
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。

int pop() 移除并返回栈顶元素。

int top() 返回栈顶元素。

boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 
## 2.说明
你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。

你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 

## 3.进阶
你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。

## 4.示例
输入：


["MyStack", "push", "push", "top", "pop", "empty"]

[[], [1], [2], [], [], []]

输出：

[null, null, null, 2, 2, false]

解释：

MyStack myStack = new MyStack();

myStack.push(1);

myStack.push(2);

myStack.top(); // 返回 2

myStack.pop(); // 返回 2

myStack.empty(); // 返回 False

## 5.提示
1 <= x <= 9

最多调用100 次 push、pop、top 和 empty

每次调用 pop 和 top 都保证栈不为空

## 6.解题思路
### 6.1两个队列的解法
为了满足栈的特性，即最后入栈的元素最先出栈，在使用队列实现栈时，应满足队列前端的元素是最后入栈的元素。可以使用两个队列实现栈的操作，
其中queue1用于存储栈内的元素，queue2作为入栈操作的辅助队列。

入栈操作时，首先将元素入队到queue2，然后将queue1的全部元素依次出队并入队到queue2，此时queue2的前端的元素即为新入栈的元素，
再将queue1和queue2互换，则queue1元素即为栈内的元素，queue1的前端和后端分别对应栈顶和栈底。

由于每次入栈操作都确保queue1的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除queue1的前端元素并返回即可，
获得栈顶元素操作只需要获得queue1的前端元素并返回即可（不移除元素）。

由于queue1用于存储栈内的元素，判断栈是否为空时，只需要判断queue1是否为空即可。

### 复杂度分析
时间复杂度：入栈操作O(n)，其余操作都是O(1)。入栈操作需要将queue1中的n个元素出队，并入队n+1个元素queue2，共有2n+1次操作，
每次出队和入队操作的时间复杂度都是O(1)，因此入栈操作的时间复杂度是O(n)。

出栈操作对应将queue1的前端元素出队，时间复杂度是O(1)。

获得栈顶元素操作对应获得queue1的前端元素，时间复杂度是O(1)。

判断栈是否为空操作只需要判断queue1是否为空，时间复杂度是O(1)。

空间复杂度：O(n)，其中n是栈内的元素。需要使用两个队列存储栈内的元素

### 6.2一个队列的解法
方法一使用了两个队列实现栈的操作，也可以使用一个队列实现栈的操作。

使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。

入栈操作时，首先获得入栈前的元素个数n，然后将元素入队到队列，再将队列中的前n个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。

由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。

由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。

### 复杂度分析
时间复杂度：入栈操作O(n)，其余操作都是O(1)。入栈操作需要将queue1中的n个元素出队，并入队n+1个元素queue2，共有2n+1次操作，
每次出队和入队操作的时间复杂度都是O(1)，因此入栈操作的时间复杂度是O(n)。

出栈操作对应将queue1的前端元素出队，时间复杂度是O(1)。

获得栈顶元素操作对应获得queue1的前端元素，时间复杂度是O(1)。

判断栈是否为空操作只需要判断queue1是否为空，时间复杂度是O(1)。

空间复杂度：O(n)，其中n是栈内的元素。需要使用两个队列存储栈内的元素
