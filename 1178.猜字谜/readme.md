# 1178. 猜字谜
难度 困难

完成日期 2021.2.26

## 1.题干
外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。

字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：

单词 word 中包含谜面 puzzle 的第一个字母。

单词 word 中的每一个字母都可以在谜面 puzzle 中找到。

例如，如果字谜的谜面是 "abcdefg"，那么可以作为谜底的单词有 "faced", "cabbage", 和 "baggage"；
而 "beefed"（不含字母 "a"）以及 "based"（其中的 "s" 没有出现在谜面中）。

返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 
puzzles[i] 所对应的谜底的单词数目。

## 2.示例
输入：

words = ["aaaa","asas","able","ability","actt","actor","access"], 

puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]

输出：[1,1,3,2,4,0]

解释：

1 个单词可以作为 "aboveyz" 的谜底 : "aaaa" 

1 个单词可以作为 "abrodyz" 的谜底 : "aaaa"

3 个单词可以作为 "abslute" 的谜底 : "aaaa", "asas", "able"

2 个单词可以作为 "absoryz" 的谜底 : "aaaa", "asas"

4 个单词可以作为 "actresz" 的谜底 : "aaaa", "asas", "actt", "access"

没有单词可以作为 "gaswxyz" 的谜底，因为列表中的单词都不含字母 'g'。

## 3.提示
1 <= words.length <= 10^5

4 <= words[i].length <= 50

1 <= puzzles.length <= 10^4

puzzles[i].length == 7

words[i][j], puzzles[i][j] 都是小写英文字母。

每个 puzzles[i] 所包含的字符都不重复。

## 4.解题思路
首先我们计算出每一个 word 对应的集合 Sw，存放在某一「数据结构」中，便于后续操作中的快速查找；

随后我们依次枚举每一个puzzle，计算出其对应的集合Sp，并枚举满足要求的子集S'p。
对于每一个S'p，我们在「数据结构」中查找其出现的次数，那么所有的 S'p出现次数之和就是puzzle对应的谜底个数。

### 方法 二进制压缩
由于题目中规定word和puzzle均只包含小写字母，因此Sw和Sp的大小最多为26，我们可以考虑使用一个长度为26的二进制数bw或bp来表示这一集合。

对于bw从低到高的第i个二进制位（i从0开始编号），如果Sw中包含第i个小写字母，那么对应的二进制位为1，否则为0。
因此我们可以使用一个哈希映射来表示需要的「数据结构」：对于哈希映射中的每一个键值对，其中的键表示一个长度为26的二进制数，
值表示其出现的次数，即数组words中多少个word 压缩成的二进制数等于键。构造哈希映射的过程也很简单：我们只需要遍历每一个word，
并遍历word 中的每一个字母，将对应位置的二进制位标记为1，这样就计算出了word对应的二进制表示，将其在哈希映射中作为键对应的值增加 11 即可。

对于puzzle 对应的bp，我们可以通过相同的方法求出，那么接下来就需要枚举bp的子集bp′了。枚举一个二进制数的子集也有多种方法，这里介绍常用的两种：

第一种：由于题目中规定puzzle 的长度恰好为7，因此我们可以枚举所有6位的二进制数
（因为 puzzle 中的首字母必须要出现，因此最高位必须是1，我们只需要枚举剩余的6位就行了）。
对于每个枚举出的6位二进制数，我们遍历puzzle中除了首字母以外的其余6个字母，只有当二进制位为1时，
我们才将puzzle中的字母在二进制表示中的二进制位标记位1。这样我们就得到了每一个bp′对应的二进制表示。

### 细节
在遍历word时，如果bw中包含的1的数量大于7，那么它一定无法作为谜底，因此我们无需将其加入哈希映射中。

### 算法复杂度
时间复杂度：O(m|w|+ n2^{|p|})O(m∣w∣+n2∣p∣ )，其中m和n分别是数组words和puzzles的长度，|w|是word的最大长度50，|p|是puzzle 的最大长度7。

时间复杂度分为三部分：

计算所有word对应的二进制表示的时间复杂度为 O(m|w|)；

计算所有puzzle对应的二进制表示的时间复杂度为 O(n|p|)；

枚举puzzle的子集的时间复杂度为 O(n2^{|p|-1})O(n2p∣−1)，这里为使用第二种方法的时间复杂度，
如果使用第一种方法，那么时间复杂度略高，为 O(n(|p|-1)2^{|p|-1})O(n(∣p∣−1)2∣p∣−1)。

由于|p|-1与|p|同阶，因此写成O(|p|)更加简洁。并且由于第三部分的时间复杂度在渐进意义下严格大于第二部分，
因此总时间复杂度即为第一部分与第三部分之和 O(m|w| + n2^{|p|})O(m∣w∣+n2∣p∣ )。

空间复杂度：O(m)，即为哈希映射需要使用的空间，其中最多只包含m个键值对。


